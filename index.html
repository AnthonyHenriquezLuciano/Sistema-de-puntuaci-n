<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Turnos</title>
    <!-- ...Tus estilos aquí... -->
    <style>
        /* ...Tus estilos existentes... */
    </style>
</head>
<body>
    <!-- ...Tu HTML existente... -->
    <!-- (puedes usar el HTML de tu archivo actual, no es necesario cambiarlo) -->

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script>
    // --- CONFIGURACIÓN Y VARIABLES ---
    const firebaseConfig = {
        apiKey: "AIzaSyAs2MmgrO0UmXtlm-HWCw2hcfqYcIg74Qs",
        authDomain: "sistema-turnos-gestores.firebaseapp.com",
        databaseURL: "https://sistema-turnos-gestores-default-rtdb.firebaseio.com",
        projectId: "sistema-turnos-gestores",
        storageBucket: "sistema-turnos-gestores.appspot.com",
        messagingSenderId: "322320112231",
        appId: "1:322320112231:web:dbb93a76a85a8906d2d2c2",
        measurementId: "G-GV4JVLKEFY"
    };

    let currentUser = null;
    let heartbeatInterval = null, globalTimerInterval = null, syncInterval = null, pageClockInterval = null, titleNotificationInterval = null;
    let isConnected = false;
    let originalTitle = document.title;
    let currentActiveUserId = null;
    let serverTimeOffset = 0;
    let isLoggingIn = false;
    let sessionListener = null;
    let sessionId = null;

    const TURN_TIME_SECONDS = 15 * 60;
    const SYNC_INTERVAL_SECONDS = 5;

    let database, auth, activeSessionsRef, connectedRef, queueRef, activeUserRef;
    const QUEUE_PATH = 'queueSystem/queue';
    const ACTIVE_USER_PATH = 'queueSystem/activeUser';
    const ACTIVE_SESSIONS_PATH = 'activeSessions';

    // --- SESIÓN ÚNICA POR PESTAÑA ---
    function getSessionId() {
        if (!sessionId) {
            sessionId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        return sessionId;
    }

    // --- INICIALIZACIÓN ---
    document.addEventListener('DOMContentLoaded', initializeApp);

    function initializeApp() {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        auth = firebase.auth();

        activeSessionsRef = database.ref(ACTIVE_SESSIONS_PATH);
        connectedRef = database.ref('.info/connected');
        queueRef = database.ref(QUEUE_PATH);
        activeUserRef = database.ref(ACTIVE_USER_PATH);

        auth.onAuthStateChanged(auth_onAuthStateChanged);

        database.ref('/.info/serverTimeOffset').on('value', (snap) => {
            serverTimeOffset = snap.val() || 0;
        });

        startPageClock();
        document.getElementById('loginButton').onclick = handleLoginClick;
        document.getElementById('passwordInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLoginClick(); });
        document.getElementById('logoutBtn').onclick = logout;
        document.getElementById('joinQueueBtn').onclick = joinQueue;
        document.getElementById('forgotPasswordLink').onclick = handleForgotPassword;
    }

    // --- CONTROLADORES DE ESTADO ---
    async function auth_onAuthStateChanged(user) {
        if (user) {
            if (currentUser && currentUser.uid === user.uid) return;
            // SESIÓN ÚNICA: verifica si hay otra sesión activa
            const sessionSnap = await activeSessionsRef.child(user.uid).once('value');
            if (sessionSnap.exists() && sessionSnap.val().status === 'active' && sessionSnap.val().sessionId && sessionSnap.val().sessionId !== getSessionId()) {
                await auth.signOut();
                showError("Ya tienes una sesión activa en otra pestaña o dispositivo.");
                return;
            }
            await onUserLoggedIn(user);
        } else {
            onUserLoggedOut();
        }
    }

    async function onUserLoggedIn(user) {
        stopAllTimersAndListeners();
        currentUser = user;
        try {
            const sessionRef = activeSessionsRef.child(user.uid);
            await sessionRef.set({
                userId: user.uid,
                email: user.email,
                loginTime: firebase.database.ServerValue.TIMESTAMP,
                status: 'active',
                sessionId: getSessionId()
            });
            await sessionRef.onDisconnect().update({ status: 'disconnected' });

            // Listener para detectar cierre de sesión en otra pestaña
            if (sessionListener) sessionRef.off('value', sessionListener);
            sessionListener = snap => {
                const data = snap.val();
                if (!data || data.status !== 'active' || data.sessionId !== getSessionId()) {
                    auth.signOut();
                    showError("Tu sesión fue cerrada en otra pestaña o dispositivo.");
                }
            };
            sessionRef.on('value', sessionListener);

            document.getElementById('userName').textContent = currentUser.email;
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('mainContainer').style.display = 'block';

            setupAppForUser();
        } catch (error) {
            showError("No se pudo configurar tu sesión. Inténtalo de nuevo.");
            await auth.signOut();
        }
    }

    function onUserLoggedOut() {
        cleanupSessionState();
    }

    function setupAppForUser() {
        setupConnectionListener();
        setupQueueListeners();
        startHeartbeat();
        activateNextInQueue();
    }

    // --- LÓGICA DE SESIÓN ---
    async function handleLoginClick() {
        if (isLoggingIn) return;
        const email = document.getElementById('emailInput').value.trim();
        const password = document.getElementById('passwordInput').value;
        if (!email || !password) return showError('Ingresa correo y contraseña.');

        const loginButton = document.getElementById('loginButton');
        const loginButtonText = document.getElementById('loginButtonText');
        isLoggingIn = true;
        loginButton.disabled = true;
        loginButtonText.innerHTML = '<span class="loading-spinner"></span> Verificando...';
        showError(null);

        try {
            await auth.signInWithEmailAndPassword(email, password);
        } catch (error) {
            showError(error.message);
        } finally {
            isLoggingIn = false;
            loginButton.disabled = false;
            loginButtonText.textContent = 'Iniciar Sesión';
        }
    }

    async function logout() {
        const logoutBtn = document.getElementById('logoutBtn');
        if (!currentUser || logoutBtn.disabled) return;
        logoutBtn.disabled = true;
        try {
            if(currentUser.uid) {
                await activeSessionsRef.child(currentUser.uid).update({ status: 'logged_out' });
            }
            await auth.signOut();
        } catch (error) {
            logoutBtn.disabled = false;
        }
    }

    function cleanupSessionState() {
        stopAllTimersAndListeners();
        currentUser = null; currentActiveUserId = null;
        document.getElementById('mainContainer').style.display = 'none';
        document.getElementById('loginModal').style.display = 'flex';
        document.getElementById('emailInput').value = '';
        document.getElementById('passwordInput').value = '';
        showError(null);
        const logoutBtn = document.getElementById('logoutBtn');
        if(logoutBtn) logoutBtn.disabled = false;
    }

    // --- LÓGICA DE COLA Y TURNOS ---
    async function joinQueue() {
        if (!isConnected || !currentUser) return;
        const joinBtn = document.getElementById('joinQueueBtn');
        joinBtn.disabled = true;
        try {
            const activeUserSnap = await activeUserRef.once('value');
            if (activeUserSnap.exists() && activeUserSnap.val().userId === currentUser.uid) {
                showNotification('Ya tienes un turno activo.', 'warning');
                return;
            }
            const queueSnap = await queueRef.orderByChild('userId').equalTo(currentUser.uid).once('value');
            if (queueSnap.exists()) {
                showNotification('Ya estás en la cola.', 'warning');
                return;
            }
            const newEntryRef = queueRef.push();
            await newEntryRef.set({
                key: newEntryRef.key,
                userId: currentUser.uid,
                email: currentUser.email,
                joinedAt: firebase.database.ServerValue.TIMESTAMP
            });
            showNotification('Te uniste a la cola.', 'success');
            const currentActiveUser = (await activeUserRef.once('value')).val();
            if (!currentActiveUser) {
                activateNextInQueue();
            }
        } catch (error) {
            showNotification(`Error al unirse: ${error.message}`, 'error');
        } finally {
            joinBtn.disabled = false;
        }
    }

    async function promoteNextUser() {
        try {
            const nextUser = await findNextValidUserInQueue();
            if (!nextUser) {
                await activeUserRef.set(null); return;
            }
            const newActiveUserData = {
                userId: nextUser.userId, email: nextUser.email, isPaused: false,
                remainingTime: TURN_TIME_SECONDS,
                lastUpdated: firebase.database.ServerValue.TIMESTAMP
            };
            const { committed } = await activeUserRef.transaction(currentData => {
                return currentData === null ? newActiveUserData : undefined;
            });
            if (committed) {
                await queueRef.child(nextUser.key).remove();
            }
        } catch (error) {}
    }

    async function activateNextInQueue() {
        try {
            const snap = await activeUserRef.once('value');
            if (snap.exists()) {
                const activeUser = snap.val();
                const sessionSnap = await activeSessionsRef.child(activeUser.userId).once('value');
                if(!sessionSnap.exists() || sessionSnap.val().status !== 'active') {
                    await promoteNextUser();
                }
            } else {
                await promoteNextUser();
            }
        } catch(error) {}
    }

    async function findNextValidUserInQueue() {
        try {
            const queueSnap = await queueRef.orderByChild('joinedAt').once('value');
            if (!queueSnap.exists()) return null;
            const queueData = queueSnap.val();
            for (const key in queueData) {
                const userInQueue = { key, ...queueData[key] };
                const sessionSnap = await activeSessionsRef.child(userInQueue.userId).once('value');
                if (sessionSnap.exists() && sessionSnap.val().status === 'active') {
                    return userInQueue;
                }
            }
            return null;
        } catch(error) {
            return null;
        }
    }

    // --- LISTENERS Y TEMPORIZADORES ---
    function setupQueueListeners() {
        activeUserRef.on('value', handleActiveUserChange);
        queueRef.on('value', (snap) => {
            renderQueue(snap.val());
            updateSummaryPanel(snap.val());
        });
    }

    function handleActiveUserChange(snap) {
        if (!currentUser) return;
        const activeUserData = snap.val();
        const newActiveUserId = activeUserData ? activeUserData.userId : null;
        renderActiveUser(activeUserData);
        updateSummaryPanel();
        stopAllTimers();
        if (activeUserData && !activeUserData.isPaused) {
            if (activeUserData.userId === currentUser.uid) {
                startClientTimer(activeUserData);
                startAuthoritativeSync();
            } else {
                updateTimerDisplayUI(activeUserData.remainingTime);
            }
        }
        if (newActiveUserId !== currentActiveUserId) {
            currentActiveUserId = newActiveUserId;
            if (newActiveUserId === currentUser.uid) {
                showTurnNotification();
            } else {
                stopTitleNotification();
            }
        }
    }

    function startClientTimer(activeUserData) {
        if (!activeUserData.lastUpdated) {
            setTimeout(() => activeUserRef.once('value').then(handleActiveUserChange), 500);
            return;
        }
        stopAllTimers();
        globalTimerInterval = setInterval(async () => {
            const snap = await activeUserRef.once('value');
            const data = snap.val();
            if (!data || data.userId !== currentUser.uid || data.isPaused) {
                clearInterval(globalTimerInterval);
                return;
            }
            const serverNow = Date.now() + serverTimeOffset;
            const elapsedMillis = serverNow - data.lastUpdated;
            const elapsedSeconds = Math.floor(elapsedMillis / 1000);
            const remaining = Math.max(0, data.remainingTime - elapsedSeconds);
            updateSummaryPanel(null, remaining);
            updateTimerDisplayUI(remaining);
            if (remaining <= 0) {
                clearInterval(globalTimerInterval);
            }
        }, 1000);
    }

    function startAuthoritativeSync() {
        stopAllTimers();
        syncInterval = setInterval(async () => {
            try {
                const snap = await activeUserRef.once('value');
                const activeUserData = snap.val();
                if (!activeUserData || activeUserData.userId !== currentUser.uid || activeUserData.isPaused) {
                    stopAllTimers(); return;
                }
                const serverNow = Date.now() + serverTimeOffset;
                const elapsed = Math.floor((serverNow - activeUserData.lastUpdated) / 1000);
                const remaining = activeUserData.remainingTime - elapsed;
                if (remaining <= 0) {
                    stopAllTimers();
                    await promoteNextUser();
                } else {
                    await activeUserRef.update({
                        remainingTime: remaining,
                        lastUpdated: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            } catch (error) {
                stopAllTimers();
            }
        }, SYNC_INTERVAL_SECONDS * 1000);
    }

    async function pauseTimer() {
        if (!currentUser) return;
        try {
            const snap = await activeUserRef.once('value');
            if(!snap.exists() || snap.val().userId !== currentUser.uid) return;
            const serverNow = Date.now() + serverTimeOffset;
            const elapsed = Math.floor((serverNow - snap.val().lastUpdated) / 1000);
            const remaining = snap.val().remainingTime - elapsed;
            await activeUserRef.update({
                isPaused: true,
                remainingTime: Math.max(0, remaining)
            });
        } catch (error) {}
    }

    async function resumeTimer() {
        if (currentUser) {
            try {
                await activeUserRef.update({
                    isPaused: false,
                    lastUpdated: firebase.database.ServerValue.TIMESTAMP
                });
            } catch (error) {}
        }
    }

    // --- PANEL DE RESUMEN DE ESPERA ---
    async function updateSummaryPanel(queueData = null, activeUserRemainingTime = -1) {
        const summaryPanel = document.getElementById('summaryPanel');
        const summaryStats = document.getElementById('summaryStats');
        if (!currentUser || !summaryPanel || !summaryStats) return;
        try {
            const finalQueueData = queueData || (await queueRef.once('value').then(s => s.val()));
            const sortedQueue = finalQueueData ? Object.values(finalQueueData).sort((a, b) => a.joinedAt - b.joinedAt) : [];
            const myQueueIndex = sortedQueue.findIndex(u => u.userId === currentUser.uid);

            if (myQueueIndex === -1) {
                summaryPanel.style.display = 'none'; return;
            }
            summaryPanel.style.display = 'block';

            const myPosition = myQueueIndex + 1;
            const usersAhead = myQueueIndex;

            let finalActiveTime = 0;
            let addActiveUserTime = true;
            if (activeUserRemainingTime >= 0) {
                finalActiveTime = activeUserRemainingTime;
            } else {
                const activeUserSnap = await activeUserRef.once('value');
                if (activeUserSnap.exists()) {
                    const activeUser = activeUserSnap.val();
                    if (activeUser.isPaused) {
                        addActiveUserTime = false;
                    } else if (activeUser.lastUpdated) {
                        const serverNow = Date.now() + serverTimeOffset;
                        const elapsed = Math.floor((serverNow - activeUser.lastUpdated) / 1000);
                        finalActiveTime = Math.max(0, activeUser.remainingTime - elapsed);
                    } else {
                        finalActiveTime = activeUser.remainingTime || 0;
                    }
                } else {
                    addActiveUserTime = false;
                }
            }

            let estimatedWaitSeconds = usersAhead * TURN_TIME_SECONDS;
            if (addActiveUserTime) {
                estimatedWaitSeconds += finalActiveTime;
            }
            const waitMinutes = Math.floor(estimatedWaitSeconds / 60);
            const waitSeconds = estimatedWaitSeconds % 60;
            const formattedWaitTime = `${waitMinutes.toString().padStart(2, '0')}:${waitSeconds.toString().padStart(2, '0')}`;

            summaryStats.innerHTML = `
                <div class="stat-item"><span class="label">Tu Posición</span><span class="value">${myPosition}</span></div>
                <div class="stat-item"><span class="label">Usuarios Delante</span><span class="value">${usersAhead}</span></div>
                <div class="stat-item"><span class="label">Tiempo Estimado</span><span class="value">${formattedWaitTime}</span></div>
            `;
        } catch(error) {}
    }

    // --- UTILIDADES Y UI ---
    function stopAllTimers() {
        if (globalTimerInterval) clearInterval(globalTimerInterval);
        globalTimerInterval = null;
        if (syncInterval) clearInterval(syncInterval);
        syncInterval = null;
    }
    function stopAllTimersAndListeners() {
        stopAllTimers();
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        heartbeatInterval = null;
        if (activeUserRef) activeUserRef.off();
        if (queueRef) queueRef.off();
        if (connectedRef) connectedRef.off();
        if (currentUser && activeSessionsRef) activeSessionsRef.child(currentUser.uid).off();
    }
    async function leaveQueue(key) {
        if (!currentUser || !key) return;
        try {
            await queueRef.child(key).remove();
            showNotification('Has salido de la cola.', 'success');
        } catch(e) {}
    }
    async function handleForgotPassword(e) {
        e.preventDefault();
        const email = document.getElementById('emailInput').value.trim();
        if (!email) { showError("Ingresa tu correo."); return; }
        try {
            await auth.sendPasswordResetEmail(email);
            showNotification(`Enlace enviado a ${email}`, 'success');
            showError(null);
        } catch (error) {
            showError(error.message);
        }
    }
    function renderActiveUser(data) {
        const activeUserInfo = document.getElementById('activeUserInfo');
        const timerControls = document.getElementById('timerControls');
        if (!activeUserInfo || !timerControls) return;
        if (!data) {
            activeUserInfo.innerHTML = 'Nadie activo';
            timerControls.innerHTML = '';
            updateTimerDisplayUI(TURN_TIME_SECONDS);
            return;
        }
        activeUserInfo.innerHTML = `<b>${data.email}</b>`;
        if (currentUser && data.userId === currentUser.uid) {
            timerControls.innerHTML = `<button id="pauseTimerBtn" class="timer-btn" ${data.isPaused ? 'disabled' : ''}><span>⏸️</span> Pausar</button> <button id="resumeTimerBtn" class="timer-btn" ${!data.isPaused ? 'disabled' : ''}><span>▶️</span> Reanudar</button>`;
            document.getElementById('pauseTimerBtn').onclick = pauseTimer;
            document.getElementById('resumeTimerBtn').onclick = resumeTimer;
        } else {
            timerControls.innerHTML = data.isPaused ? '<i>Turno en pausa</i>' : '';
        }
    }
    function renderQueue(queueData) {
        const queueListBody = document.querySelector('#queueListBody');
        if(!queueListBody) return;
        queueListBody.innerHTML = '';
        if (!queueData) {
            queueListBody.innerHTML = '<tr><td colspan="4">No hay usuarios en espera</td></tr>';
            return;
        }
        const sortedQueue = Object.values(queueData).sort((a, b) => a.joinedAt - b.joinedAt);
        if (sortedQueue.length === 0) {
            queueListBody.innerHTML = '<tr><td colspan="4">No hay usuarios en espera</td></tr>';
            return;
        }
        sortedQueue.forEach((q, index) => {
            const tr = document.createElement('tr');
            if (currentUser && q.userId === currentUser.uid) tr.classList.add('current-user');
            let actionCell = 'En espera';
            if (currentUser && q.userId === currentUser.uid) {
                actionCell = `<button class="leave-queue-btn" onclick="leaveQueue('${q.key}')">Salir</button>`;
            }
            tr.innerHTML = `<td>${index + 1}</td> <td>${q.email}</td> <td>${new Date(q.joinedAt).toLocaleTimeString('es-DO')}</td> <td>${actionCell}</td>`;
            queueListBody.appendChild(tr);
        });
    }
    function updateTimerDisplayUI(seconds) {
        const timerText = document.getElementById('timerText');
        const timerProgress = document.getElementById('timerProgress');
        if(!timerText || !timerProgress) return;
        const remaining = Math.max(0, seconds);
        timerText.textContent = `${Math.floor(remaining / 60).toString().padStart(2, '0')}:${(remaining % 60).toString().padStart(2, '0')}`;
        const progress = TURN_TIME_SECONDS > 0 ? remaining / TURN_TIME_SECONDS : 0;
        timerProgress.style.strokeDashoffset = 408.4 * (1 - progress);
    }
    function setupConnectionListener() {
        connectedRef.on('value', (snap) => {
            isConnected = snap.val() === true;
            updateConnectionStatus();
            if(isConnected && currentUser) {
                activateNextInQueue();
            }
        });
    }
    function updateConnectionStatus() {
        const el=document.getElementById('connectionStatus');
        if(el) {
            el.textContent = isConnected ? '🟢 Conectado' : '🔴 Desconectado';
            el.className = `connection-status ${isConnected ? 'connected' : 'disconnected'}`;
        }
    }
    function startHeartbeat() {
        stopHeartbeat();
        heartbeatInterval = setInterval(async () => {
            if (currentUser && isConnected) {
                try {
                    await activeSessionsRef.child(currentUser.uid).update({ lastHeartbeatTime: firebase.database.ServerValue.TIMESTAMP });
                } catch (error) {}
            }
        }, 30000);
    }
    function stopHeartbeat() { clearInterval(heartbeatInterval); }
    function startPageClock() {
        if (pageClockInterval) clearInterval(pageClockInterval);
        pageClockInterval = setInterval(updateCurrentTime, 1000);
    }
    function updateCurrentTime() {
        const el = document.getElementById('currentTime');
        if (el) {
            el.textContent = new Date().toLocaleString('es-DO', { dateStyle: 'long', timeStyle: 'short' });
        }
    }
    function showError(m) {
        const el=document.getElementById('userError');
        if(el) { el.style.display=m?'block':'none'; el.textContent=m; }
    }
    function showNotification(m,t='success') {
        const el=document.getElementById('notification');
        if(el) {
            el.textContent=m;
            el.className=`notification ${t} show`;
            setTimeout(()=>el.classList.remove('show'),4000);
        }
    }
    function showTurnNotification() {
        showNotification('¡Es tu turno!', 'success');
        if (Notification.permission === "granted") {
            new Notification("Sistema de Turnos", { body: "¡Es tu turno! Tienes 15 minutos.", icon: "/favicon.ico" });
        }
        stopTitleNotification();
        let isTitleVisible = true;
        titleNotificationInterval = setInterval(() => {
            document.title = isTitleVisible ? "¡ES TU TURNO!" : originalTitle;
            isTitleVisible = !isTitleVisible;
        }, 1000);
    }
    function stopTitleNotification() {
        if (titleNotificationInterval) clearInterval(titleNotificationInterval);
        titleNotificationInterval = null;
        document.title = originalTitle;
    }
    function requestNotificationPermission() {
        if ('Notification' in window && Notification.permission !== "denied") {
            Notification.requestPermission();
        }
    }
    function showErrorScreen(m) {
        stopAllTimersAndListeners();
        if(pageClockInterval) clearInterval(pageClockInterval);
        document.body.innerHTML=`<div style="display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 20px; text-align: center; background-color: var(--color-background);"><div style="background: var(--color-surface); padding: 40px; border-radius: var(--border-radius); box-shadow: var(--shadow);"><h2 style="color: var(--color-danger); font-size: 1.8em;">🆘 Error Crítico</h2><p style="margin: 20px 0; color: var(--color-text-primary);">${m}</p><button style="background:var(--color-primary); color:white; padding:12px 25px; border-radius:8px; cursor:pointer; border: none; font-size: 1em;" onclick="window.location.reload()">🔄 Recargar Página</button></div></div>`;
    }
    </script>
</body>
</html>
